{"version":3,"sources":["game/util.js","game/Point.js","game/Input.js","game/shaders/shaders.js","game/shaders/darken-x.frag.js","game/shaders/darken-y.frag.js","game/shaders/sky.frag.js","game/math/triangulate.js","game/math/convex.js","game/World.js","game/Game.js","App.js","serviceWorker.js","index.js"],"names":["scale","scaleToPhysics","x","scaleToWorld","getScreenCenter","Point","window","innerWidth","innerHeight","inside","point","vs","y","i","j","length","xi","yi","xj","yj","Object","classCallCheck","this","pixiPoint","PIXI","vecPoint","planck","util","Input","world","app","offset","multiplier","check","stage","interactive","_this","graphics","lineStyle","moveTo","lineTo","rotation","line","generateCanvasTexture","alpha","addChild","mousemove","event","mouseMove","mousedown","mouseDown","physics","on","fixture","delta","player","sprite","force","velocity","body","getLinearVelocity","Math","abs","setAwake","center","ang","atan2","mouse","cos","sin","applyLinearImpulse","toVec2","getWorldCenter","data","global","o","u","distance","sqrt","darkenMinusXShader","darkenMinusYShader","skyUniforms","color1","type","value","Float32Array","color2","amount","skyShader","EPSILON","pow","EDGE_STACK","Uint32Array","Triangulator","coords","n","Error","maxTriangles","triangles","halfedges","Int32Array","_hashSize","ceil","hullPrev","hullNext","hullTri","hullHash","fill","ids","minX","Infinity","minY","maxX","maxY","i0","i1","i2","cx","cy","minDist","d","dist","i0x","i0y","i1x","i1y","minRadius","r","circumradius","i2x","i2y","orient","ax","ay","bx","by","dx","dy","ex","ey","bl","cl","circumcenter","_cx","_cy","dists","Float64Array","quicksort","left","right","temp","tempDist","median","swap","hullStart","hullSize","_hashKey","trianglesLen","_addTriangle","xp","yp","k","start","key","e","q","t","_legalize","hull","subarray","points","getX","arguments","undefined","defaultGetX","getY","defaultGetY","p","floor","pseudoAngle","a","ar","b","a0","b0","al","p0","pr","pl","p1","inCircle","hbl","_link","br","c","px","py","qx","qy","rx","ry","fx","fy","bp","cp","arr","tmp","Convex","lineInt","l1","l2","precision","a1","b1","c1","a2","b2","c2","det","scalar_eq","triangleArea","isLeft","isLeftOn","isRight","isRightOn","decomp","polygon","edges","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","polygonIsReflex","polygonCanSee","polygonCopy","push","polygonAt","polygonSlice","cutEdges","Array","polys","cutEdge","poly","result","splice","indexOf","makeCCW","v","N","pop","polygonReverse","sqdist","s","tmpLine1","tmpLine2","targetPoly","polygonClear","definitions","ground","internal","colors","color","position","tree","darkenShaders","World","game","input","objects","gravity","physicsStage","createBody","resizeBus","background","clear","beginFill","drawRect","renderer","width","height","definition","max","shapes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","map","array","err","return","console","log","index","shape","texture","bakeStageTexture","name","backgroundShader","shader","uniforms","filters","addStageObject","createPlayer","init","step","playerPosition","getPosition","getAngularVelocity","set","tracer","updateOwnerPos","update","tick","drawCircle","generateTexture","anchor","bullet","linearDamping","allowSleep","createFixture","restitution","friction","density","container","PIXIParticles","resources","end","minimumScaleMultiplier","speed","minimumSpeedMultiplier","acceleration","maxSpeed","startRotation","noRotation","rotationSpeed","lifetime","blendMode","frequency","emitterLifetime","maxParticles","pos","addAtBack","spawnType","emit","def","objectSpread","multiply","Date","drawPolygon","toPixiPoint","endFill","bounds","getBounds","textures","pointsets","random","toArray","concat","toConsumableArray","from","primary","primaryDistance","accent","accentDistance","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","disance","ratio","tex","ADD","render","LINEAR","_i2","destroy","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","object","add","Game","PRECISION_FRAGMENT","HIGH","Settings","velocityThreshold","transparent","autoResize","resize","onresize","element","_this2","children","appendChild","view","load","initializeRender","_this3","ticker","FXAAFilter","handler","App","props","possibleConstructorReturn","getPrototypeOf","call","react_default","createElement","ref","injectPixiContext","Component","Boolean","location","hostname","match","ReactDOM","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c7b018cc.chunk.js","sourcesContent":["import Point from './Point';\r\n\r\nconst scale = 20;\r\n\r\nexport function scaleToPhysics(x) {\r\n    return x / scale;\r\n}\r\n\r\nexport function scaleToWorld(x) {\r\n    return x * scale;\r\n}\r\n\r\nexport function normalize(point, len) {\r\n    if ((point.x === 0 && point.y === 0)) {\r\n        return new Point(0, 0);\r\n    }\r\n    const angle = Math.atan2(point.y, point.x);\r\n    const nx = Math.cos(angle) * len;\r\n    const ny = Math.sin(angle) * len;\r\n    return new Point(nx, ny);\r\n}\r\n\r\nexport function toDegrees(angle) {\r\n    return angle * (180 / Math.PI);\r\n}\r\n\r\nexport function toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nexport function getScreenCenter() {\r\n    return new Point((window.innerWidth / 2), (window.innerHeight / 2));\r\n}\r\n\r\nexport function distance(o, u) {\r\n    return Math.sqrt(((o.y - u.y) * (o.y - u.y)) + ((o.x - u.x) * (o.x - u.x)));\r\n}\r\n\r\nexport function inside(point, vs) {\r\n    // ray-casting algorithm based on\r\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n    let x = point[0], y = point[1];\r\n    let inside = false;\r\n    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n        let xi = vs[i][0], yi = vs[i][1];\r\n        let xj = vs[j][0], yj = vs[j][1];\r\n\r\n        let intersect = ((yi > y) !== (yj > y))\r\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n        if (intersect) inside = !inside;\r\n    }\r\n    return inside;\r\n}","import * as PIXI from 'pixi.js';\r\nimport * as planck from 'planck-js';\r\nimport * as util from './util';\r\n\r\nclass Point {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.pixiPoint = new PIXI.Point(this.x, this.y);\r\n        this.vecPoint = planck.Vec2(this.x, this.y);\r\n    }\r\n\r\n    add(x, y) {\r\n        return new Point(this.x + x, this.y + y);\r\n    }\r\n\r\n    multiply(x, y) {\r\n        return new Point(this.x * x, this.y * y);\r\n    }\r\n\r\n    toPixiPoint() {\r\n        return this.pixiPoint;\r\n    }\r\n\r\n    toVec2() {\r\n        return this.vecPoint;\r\n    }\r\n\r\n    toArray() {\r\n        return [this.x, this.y];\r\n    }\r\n\r\n    scaleToPhysics() {\r\n        return new Point(util.scaleToPhysics(this.x), util.scaleToPhysics(this.y));\r\n    }\r\n}\r\n\r\nexport default Point;","import * as PIXI from 'pixi.js'\r\nimport Point from './Point';\r\nimport * as util from './util';\r\n\r\nclass Input {\r\n    constructor(world) {\r\n        this.world = world;\r\n        this.app = world.app;\r\n        this.offset = new Point(0, 0);\r\n        this.multiplier = 1;\r\n        this.check = 30;\r\n        this.app.stage.interactive = true;\r\n    }\r\n\r\n    init() {\r\n        const graphics = new PIXI.Graphics();\r\n        graphics.lineStyle(10, 0xffffff);\r\n        graphics.moveTo(0, 0).lineTo(10, 0);\r\n        graphics.x = 500;\r\n        graphics.y = 500;\r\n        graphics.rotation = 0;\r\n        this.line = new PIXI.Sprite(graphics.generateCanvasTexture());\r\n        this.line.alpha = 0.2;\r\n        this.app.stage.addChild(this.line);\r\n\r\n        this.app.stage.mousemove = (event) => this.mouseMove(event);\r\n        this.app.stage.mousedown = (event) => this.mouseDown(event);\r\n\r\n        this.world.physics.on(\"begin-contact\", (fixture) => {\r\n            this.multiplier = 0;\r\n        });\r\n    }\r\n\r\n    tick(delta) {\r\n        this.line.x = this.world.player.sprite.x + this.offset.x;\r\n        this.line.y = this.world.player.sprite.y + this.offset.y;\r\n        this.line.scale.x = this.multiplier < 0.05 ? 0 : this.force / 20 * this.multiplier;\r\n\r\n        const velocity = this.world.player.body.getLinearVelocity();\r\n        if (Math.abs(velocity.x) + Math.abs(velocity.y) < 0.005) {\r\n            this.check--;\r\n        }\r\n        if (this.check <= 0) {\r\n            this.multiplier = 1;\r\n            this.check = 30;\r\n            this.world.player.body.setAwake(false);\r\n        }\r\n\r\n        // cheat mode\r\n        //this.multiplier = 1;\r\n    }\r\n\r\n    mouseDown(event) {\r\n        const force = 0.7;\r\n        this.multiplier *= 0.5;\r\n        if (this.multiplier < 0.05) {\r\n            return;\r\n        }\r\n\r\n        const center = util.getScreenCenter();\r\n        const ang = Math.atan2(this.mouse.y - center.y, this.mouse.x - center.x);\r\n        const x = -Math.cos(ang) * force * util.scaleToPhysics(this.force) * this.multiplier;\r\n        const y = -Math.sin(ang) * force * util.scaleToPhysics(this.force) * this.multiplier;\r\n        this.world.player.body.applyLinearImpulse(new Point(x, y).scaleToPhysics().toVec2(), this.world.player.body.getWorldCenter(), true);\r\n    }\r\n\r\n    mouseMove(event) {\r\n        const center = util.getScreenCenter();\r\n        this.mouse = new Point(event.data.global.x, event.data.global.y);\r\n        const ang = Math.atan2(this.mouse.y - center.y, this.mouse.x - center.x);\r\n        const offsetAmount = 20;\r\n        this.offset = new Point(Math.cos(ang) * offsetAmount, Math.sin(ang) * offsetAmount);\r\n        this.line.rotation = ang;\r\n\r\n        const distance = util.distance(new Point(this.mouse.x, this.mouse.y), center);\r\n        this.force = distance;\r\n    }\r\n}\r\n\r\nexport default Input;","import * as PIXI from 'pixi.js';\r\nimport skyFrag from './sky.frag.js'\r\nimport darkenMinusX from './darken-x.frag.js'\r\nimport darkenMinusY from './darken-y.frag.js'\r\n\r\nconst darkenMinusXShader = new PIXI.Filter('', darkenMinusX);\r\nconst darkenMinusYShader = new PIXI.Filter('', darkenMinusY);\r\nexport function darken() {\r\n    return [darkenMinusXShader, darkenMinusYShader];\r\n}\r\n\r\nconst skyUniforms = {\r\n    color1: {\r\n        type: \"vec3\",\r\n        value: new Float32Array([0.2, 0.4, 1.0]),\r\n    },\r\n    color2: {\r\n        type: \"vec3\",\r\n        value: new Float32Array([0, 1.0, 0])\r\n    },\r\n    amount: {\r\n        type: \"f\",\r\n        value: 0.4\r\n    }\r\n}\r\nconst skyShader = new PIXI.Filter('', skyFrag, skyUniforms);\r\nexport function sky() {\r\n    return {\r\n        shader: skyShader,\r\n        uniforms: skyUniforms\r\n    }\r\n}\r\n\r\nfunction hexToRgb(hex) {\r\n    var r = (hex >> 16) & 255;\r\n    var g = (hex >> 8) & 255;\r\n    var b = hex & 255;\r\n\r\n    return (r / 255).toFixed(3) + \",\" + (b / 255).toFixed(3) + \",\" + (g / 255).toFixed(3);\r\n\r\n}","export default `\r\nprecision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D vTexture;\r\n\r\nvoid main(){\r\n\tif (texture2D(vTexture, vTextureCoord).a != 1.0) {\r\n        discard;\r\n    }\r\n\tvec2 uvs = vTextureCoord.xy;\r\n\r\n\tvec4 fg = texture2D(vTexture, vTextureCoord);\r\n\tfg.r = mix(1.0-uvs.x, fg.r, 0.7);\r\n\tfg.b = mix(1.0-uvs.x, fg.b, 0.7);\r\n\tfg.g = mix(1.0-uvs.x, fg.g, 0.7);\r\n\r\n\tgl_FragColor = fg;\r\n}`","export default `\r\nprecision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D vTexture;\r\n\r\nvoid main(){\r\n\tif (texture2D(vTexture, vTextureCoord).a != 1.0) {\r\n        discard;\r\n    }\r\n\tvec2 uvs = vTextureCoord.xy;\r\n\r\n\tvec4 fg = texture2D(vTexture, vTextureCoord);\r\n\tfg.r = mix(1.0-uvs.y, fg.r, 0.7);\r\n\tfg.b = mix(1.0-uvs.y, fg.b, 0.7);\r\n\tfg.g = mix(1.0-uvs.y, fg.g, 0.7);\r\n\r\n\tgl_FragColor = fg;\r\n}`","export default `\r\nprecision mediump float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform vec3 color1;\r\nuniform vec3 color2;\r\nuniform float amount;\r\n\r\nvoid main(){\r\n\tvec2 uvs = vTextureCoord.xy;\r\n\tvec4 fg = vec4(0.0, 0.0, 0.0, 1.0);\r\n\tfg.r = mix(color1.r, color2.r, uvs.y *  amount);\r\n\tfg.b = mix(color1.b, color2.b, uvs.y *  amount);\r\n\tfg.g = mix(color1.g, color2.g, uvs.y *  amount);\r\n\r\n\tgl_FragColor = fg;\r\n}`","/* eslint-disable */\r\n// https://github.com/mapbox/delaunator\r\n\r\nconst EPSILON = Math.pow(2, -52);\r\nconst EDGE_STACK = new Uint32Array(512);\r\n\r\nexport default class Triangulator {\r\n\r\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\r\n        const n = points.length;\r\n        const coords = new Float64Array(n * 2);\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            const p = points[i];\r\n            coords[2 * i] = getX(p);\r\n            coords[2 * i + 1] = getY(p);\r\n        }\r\n\r\n        return new Triangulator(coords);\r\n    }\r\n\r\n    constructor(coords) {\r\n        const n = coords.length >> 1;\r\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\r\n\r\n        this.coords = coords;\r\n\r\n        // arrays that will store the triangulation graph\r\n        const maxTriangles = 2 * n - 5;\r\n        const triangles = this.triangles = new Uint32Array(maxTriangles * 3);\r\n        const halfedges = this.halfedges = new Int32Array(maxTriangles * 3);\r\n\r\n        // temporary arrays for tracking the edges of the advancing convex hull\r\n        this._hashSize = Math.ceil(Math.sqrt(n));\r\n        const hullPrev = this.hullPrev = new Uint32Array(n); // edge to prev edge\r\n        const hullNext = this.hullNext = new Uint32Array(n); // edge to next edge\r\n        const hullTri = this.hullTri = new Uint32Array(n); // edge to adjacent triangle\r\n        const hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash\r\n\r\n        // populate an array of point indices; calculate input data bbox\r\n        const ids = new Uint32Array(n);\r\n        let minX = Infinity;\r\n        let minY = Infinity;\r\n        let maxX = -Infinity;\r\n        let maxY = -Infinity;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            const x = coords[2 * i];\r\n            const y = coords[2 * i + 1];\r\n            if (x < minX) minX = x;\r\n            if (y < minY) minY = y;\r\n            if (x > maxX) maxX = x;\r\n            if (y > maxY) maxY = y;\r\n            ids[i] = i;\r\n        }\r\n        const cx = (minX + maxX) / 2;\r\n        const cy = (minY + maxY) / 2;\r\n\r\n        let minDist = Infinity;\r\n        let i0, i1, i2;\r\n\r\n        // pick a seed point close to the center\r\n        for (let i = 0; i < n; i++) {\r\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\r\n            if (d < minDist) {\r\n                i0 = i;\r\n                minDist = d;\r\n            }\r\n        }\r\n        const i0x = coords[2 * i0];\r\n        const i0y = coords[2 * i0 + 1];\r\n\r\n        minDist = Infinity;\r\n\r\n        // find the point closest to the seed\r\n        for (let i = 0; i < n; i++) {\r\n            if (i === i0) continue;\r\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\r\n            if (d < minDist && d > 0) {\r\n                i1 = i;\r\n                minDist = d;\r\n            }\r\n        }\r\n        let i1x = coords[2 * i1];\r\n        let i1y = coords[2 * i1 + 1];\r\n\r\n        let minRadius = Infinity;\r\n\r\n        // find the third point which forms the smallest circumcircle with the first two\r\n        for (let i = 0; i < n; i++) {\r\n            if (i === i0 || i === i1) continue;\r\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\r\n            if (r < minRadius) {\r\n                i2 = i;\r\n                minRadius = r;\r\n            }\r\n        }\r\n        let i2x = coords[2 * i2];\r\n        let i2y = coords[2 * i2 + 1];\r\n\r\n        if (minRadius === Infinity) {\r\n            throw new Error('No Delaunay triangulation exists for this input.');\r\n        }\r\n\r\n        // swap the order of the seed points for counter-clockwise orientation\r\n        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\r\n            const i = i1;\r\n            const x = i1x;\r\n            const y = i1y;\r\n            i1 = i2;\r\n            i1x = i2x;\r\n            i1y = i2y;\r\n            i2 = i;\r\n            i2x = x;\r\n            i2y = y;\r\n        }\r\n\r\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\r\n        this._cx = center.x;\r\n        this._cy = center.y;\r\n\r\n        const dists = new Float64Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\r\n        }\r\n\r\n        // sort the points by distance from the seed triangle circumcenter\r\n        quicksort(ids, dists, 0, n - 1);\r\n\r\n        // set up the seed triangle as the starting hull\r\n        this.hullStart = i0;\r\n        let hullSize = 3;\r\n\r\n        hullNext[i0] = hullPrev[i2] = i1;\r\n        hullNext[i1] = hullPrev[i0] = i2;\r\n        hullNext[i2] = hullPrev[i1] = i0;\r\n\r\n        hullTri[i0] = 0;\r\n        hullTri[i1] = 1;\r\n        hullTri[i2] = 2;\r\n\r\n        hullHash[this._hashKey(i0x, i0y)] = i0;\r\n        hullHash[this._hashKey(i1x, i1y)] = i1;\r\n        hullHash[this._hashKey(i2x, i2y)] = i2;\r\n\r\n        this.trianglesLen = 0;\r\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\r\n\r\n        for (let k = 0, xp, yp; k < ids.length; k++) {\r\n            const i = ids[k];\r\n            const x = coords[2 * i];\r\n            const y = coords[2 * i + 1];\r\n\r\n            // skip near-duplicate points\r\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\r\n            xp = x;\r\n            yp = y;\r\n\r\n            // skip seed triangle points\r\n            if (i === i0 || i === i1 || i === i2) continue;\r\n\r\n            // find a visible edge on the convex hull using edge hash\r\n            let start = 0;\r\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\r\n                start = hullHash[(key + j) % this._hashSize];\r\n                if (start !== -1 && start !== hullNext[start]) break;\r\n            }\r\n\r\n            start = hullPrev[start];\r\n            let e = start, q;\r\n            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\r\n                e = q;\r\n                if (e === start) {\r\n                    e = -1;\r\n                    break;\r\n                }\r\n            }\r\n            if (e === -1) continue; // likely a near-duplicate point; skip it\r\n\r\n            // add the first triangle from the point\r\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\r\n\r\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\r\n            hullTri[i] = this._legalize(t + 2);\r\n            hullTri[e] = t; // keep track of boundary triangles on the hull\r\n            hullSize++;\r\n\r\n            // walk forward through the hull, adding more triangles and flipping recursively\r\n            let n = hullNext[e];\r\n            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {\r\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\r\n                hullTri[i] = this._legalize(t + 2);\r\n                hullNext[n] = n; // mark as removed\r\n                hullSize--;\r\n                n = q;\r\n            }\r\n\r\n            // walk backward from the other side, adding more triangles and flipping\r\n            if (e === start) {\r\n                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\r\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\r\n                    this._legalize(t + 2);\r\n                    hullTri[q] = t;\r\n                    hullNext[e] = e; // mark as removed\r\n                    hullSize--;\r\n                    e = q;\r\n                }\r\n            }\r\n\r\n            // update the hull indices\r\n            this.hullStart = hullPrev[i] = e;\r\n            hullNext[e] = hullPrev[n] = i;\r\n            hullNext[i] = n;\r\n\r\n            // save the two new edges in the hash table\r\n            hullHash[this._hashKey(x, y)] = i;\r\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\r\n        }\r\n\r\n        this.hull = new Uint32Array(hullSize);\r\n        for (let i = 0, e = this.hullStart; i < hullSize; i++) {\r\n            this.hull[i] = e;\r\n            e = hullNext[e];\r\n        }\r\n        this.hullPrev = this.hullNext = this.hullTri = null; // get rid of temporary arrays\r\n\r\n        // trim typed triangle mesh arrays\r\n        this.triangles = triangles.subarray(0, this.trianglesLen);\r\n        this.halfedges = halfedges.subarray(0, this.trianglesLen);\r\n    }\r\n\r\n    _hashKey(x, y) {\r\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\r\n    }\r\n\r\n    _legalize(a) {\r\n        const {triangles, coords, halfedges} = this;\r\n\r\n        let i = 0;\r\n        let ar = 0;\r\n\r\n        // recursion eliminated with a fixed-size stack\r\n        while (true) {\r\n            const b = halfedges[a];\r\n\r\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\r\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\r\n             * then do the same check/flip recursively for the new pair of triangles\r\n             *\r\n             *           pl                    pl\r\n             *          /||\\                  /  \\\r\n             *       al/ || \\bl            al/    \\a\r\n             *        /  ||  \\              /      \\\r\n             *       /  a||b  \\    flip    /___ar___\\\r\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\r\n             *        \\  ||  /              \\      /\r\n             *       ar\\ || /br             b\\    /br\r\n             *          \\||/                  \\  /\r\n             *           pr                    pr\r\n             */\r\n            const a0 = a - a % 3;\r\n            ar = a0 + (a + 2) % 3;\r\n\r\n            if (b === -1) { // convex hull edge\r\n                if (i === 0) break;\r\n                a = EDGE_STACK[--i];\r\n                continue;\r\n            }\r\n\r\n            const b0 = b - b % 3;\r\n            const al = a0 + (a + 1) % 3;\r\n            const bl = b0 + (b + 2) % 3;\r\n\r\n            const p0 = triangles[ar];\r\n            const pr = triangles[a];\r\n            const pl = triangles[al];\r\n            const p1 = triangles[bl];\r\n\r\n            const illegal = inCircle(\r\n                coords[2 * p0], coords[2 * p0 + 1],\r\n                coords[2 * pr], coords[2 * pr + 1],\r\n                coords[2 * pl], coords[2 * pl + 1],\r\n                coords[2 * p1], coords[2 * p1 + 1]);\r\n\r\n            if (illegal) {\r\n                triangles[a] = p1;\r\n                triangles[b] = p0;\r\n\r\n                const hbl = halfedges[bl];\r\n\r\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\r\n                if (hbl === -1) {\r\n                    let e = this.hullStart;\r\n                    do {\r\n                        if (this.hullTri[e] === bl) {\r\n                            this.hullTri[e] = a;\r\n                            break;\r\n                        }\r\n                        e = this.hullNext[e];\r\n                    } while (e !== this.hullStart);\r\n                }\r\n                this._link(a, hbl);\r\n                this._link(b, halfedges[ar]);\r\n                this._link(ar, bl);\r\n\r\n                const br = b0 + (b + 1) % 3;\r\n\r\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\r\n                if (i < EDGE_STACK.length) {\r\n                    EDGE_STACK[i++] = br;\r\n                }\r\n            } else {\r\n                if (i === 0) break;\r\n                a = EDGE_STACK[--i];\r\n            }\r\n        }\r\n\r\n        return ar;\r\n    }\r\n\r\n    _link(a, b) {\r\n        this.halfedges[a] = b;\r\n        if (b !== -1) this.halfedges[b] = a;\r\n    }\r\n\r\n    // add a new triangle given vertex indices and adjacent half-edge ids\r\n    _addTriangle(i0, i1, i2, a, b, c) {\r\n        const t = this.trianglesLen;\r\n\r\n        this.triangles[t] = i0;\r\n        this.triangles[t + 1] = i1;\r\n        this.triangles[t + 2] = i2;\r\n\r\n        this._link(t, a);\r\n        this._link(t + 1, b);\r\n        this._link(t + 2, c);\r\n\r\n        this.trianglesLen += 3;\r\n\r\n        return t;\r\n    }\r\n}\r\n\r\n// monotonically increases with real angle, but doesn't need expensive trigonometry\r\nfunction pseudoAngle(dx, dy) {\r\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\r\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\r\n}\r\n\r\nfunction dist(ax, ay, bx, by) {\r\n    const dx = ax - bx;\r\n    const dy = ay - by;\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\nfunction orient(px, py, qx, qy, rx, ry) {\r\n    return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < 0;\r\n}\r\n\r\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\r\n    const dx = ax - px;\r\n    const dy = ay - py;\r\n    const ex = bx - px;\r\n    const ey = by - py;\r\n    const fx = cx - px;\r\n    const fy = cy - py;\r\n\r\n    const ap = dx * dx + dy * dy;\r\n    const bp = ex * ex + ey * ey;\r\n    const cp = fx * fx + fy * fy;\r\n\r\n    return dx * (ey * cp - bp * fy) -\r\n           dy * (ex * cp - bp * fx) +\r\n           ap * (ex * fy - ey * fx) < 0;\r\n}\r\n\r\nfunction circumradius(ax, ay, bx, by, cx, cy) {\r\n    const dx = bx - ax;\r\n    const dy = by - ay;\r\n    const ex = cx - ax;\r\n    const ey = cy - ay;\r\n\r\n    const bl = dx * dx + dy * dy;\r\n    const cl = ex * ex + ey * ey;\r\n    const d = 0.5 / (dx * ey - dy * ex);\r\n\r\n    const x = (ey * bl - dy * cl) * d;\r\n    const y = (dx * cl - ex * bl) * d;\r\n\r\n    return x * x + y * y;\r\n}\r\n\r\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\r\n    const dx = bx - ax;\r\n    const dy = by - ay;\r\n    const ex = cx - ax;\r\n    const ey = cy - ay;\r\n\r\n    const bl = dx * dx + dy * dy;\r\n    const cl = ex * ex + ey * ey;\r\n    const d = 0.5 / (dx * ey - dy * ex);\r\n\r\n    const x = ax + (ey * bl - dy * cl) * d;\r\n    const y = ay + (dx * cl - ex * bl) * d;\r\n\r\n    return {x, y};\r\n}\r\n\r\nfunction quicksort(ids, dists, left, right) {\r\n    if (right - left <= 20) {\r\n        for (let i = left + 1; i <= right; i++) {\r\n            const temp = ids[i];\r\n            const tempDist = dists[temp];\r\n            let j = i - 1;\r\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\r\n            ids[j + 1] = temp;\r\n        }\r\n    } else {\r\n        const median = (left + right) >> 1;\r\n        let i = left + 1;\r\n        let j = right;\r\n        swap(ids, median, i);\r\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\r\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\r\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\r\n\r\n        const temp = ids[i];\r\n        const tempDist = dists[temp];\r\n        while (true) {\r\n            do i++; while (dists[ids[i]] < tempDist);\r\n            do j--; while (dists[ids[j]] > tempDist);\r\n            if (j < i) break;\r\n            swap(ids, i, j);\r\n        }\r\n        ids[left + 1] = ids[j];\r\n        ids[j] = temp;\r\n\r\n        if (right - i + 1 >= j - left) {\r\n            quicksort(ids, dists, i, right);\r\n            quicksort(ids, dists, left, j - 1);\r\n        } else {\r\n            quicksort(ids, dists, left, j - 1);\r\n            quicksort(ids, dists, i, right);\r\n        }\r\n    }\r\n}\r\n\r\nfunction swap(arr, i, j) {\r\n    const tmp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = tmp;\r\n}\r\n\r\nfunction defaultGetX(p) {\r\n    return p[0];\r\n}\r\nfunction defaultGetY(p) {\r\n    return p[1];\r\n}","/* eslint-disable */\r\n// https://github.com/schteppe/poly-decomp.js/\r\n\r\n// module.exports = {\r\n//     decomp: polygonDecomp,\r\n//     quickDecomp: polygonQuickDecomp,\r\n//     isSimple: polygonIsSimple,\r\n//     removeCollinearPoints: polygonRemoveCollinearPoints,\r\n//     removeDuplicatePoints: polygonRemoveDuplicatePoints,\r\n//     makeCCW: polygonMakeCCW\r\n// };\r\n\r\nexport default class Convex {\r\n    static decomp = polygonDecomp;\r\n    static makeCCW = polygonMakeCCW;\r\n}\r\n\r\n/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */\r\nfunction lineInt(l1,l2,precision){\r\n    precision = precision || 0;\r\n    var i = [0,0]; // point\r\n    var a1, b1, c1, a2, b2, c2, det; // scalars\r\n    a1 = l1[1][1] - l1[0][1];\r\n    b1 = l1[0][0] - l1[1][0];\r\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\r\n    a2 = l2[1][1] - l2[0][1];\r\n    b2 = l2[0][0] - l2[1][0];\r\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\r\n    det = a1 * b2 - a2*b1;\r\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\r\n        i[0] = (b2 * c1 - b1 * c2) / det;\r\n        i[1] = (a1 * c2 - a2 * c1) / det;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {Boolean} True if the two line segments intersect\r\n */\r\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\r\n\tvar dx = p2[0] - p1[0];\r\n\tvar dy = p2[1] - p1[1];\r\n\tvar da = q2[0] - q1[0];\r\n\tvar db = q2[1] - q1[1];\r\n\r\n\t// segments are parallel\r\n\tif((da*dy - db*dx) === 0){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\r\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\r\n\r\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\r\n}\r\n\r\n/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */\r\nfunction triangleArea(a,b,c){\r\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\r\n}\r\n\r\nfunction isLeft(a,b,c){\r\n    return triangleArea(a,b,c) > 0;\r\n}\r\n\r\nfunction isLeftOn(a,b,c) {\r\n    return triangleArea(a, b, c) >= 0;\r\n}\r\n\r\nfunction isRight(a,b,c) {\r\n    return triangleArea(a, b, c) < 0;\r\n}\r\n\r\nfunction isRightOn(a,b,c) {\r\n    return triangleArea(a, b, c) <= 0;\r\n}\r\n\r\nvar tmpPoint1 = [],\r\n    tmpPoint2 = [];\r\n\r\n/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {Boolean}\r\n */\r\nfunction collinear(a,b,c,thresholdAngle) {\r\n    if(!thresholdAngle){\r\n        return triangleArea(a, b, c) === 0;\r\n    } else {\r\n        var ab = tmpPoint1,\r\n            bc = tmpPoint2;\r\n\r\n        ab[0] = b[0]-a[0];\r\n        ab[1] = b[1]-a[1];\r\n        bc[0] = c[0]-b[0];\r\n        bc[1] = c[1]-b[1];\r\n\r\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\r\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\r\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\r\n            angle = Math.acos(dot/(magA*magB));\r\n        return angle < thresholdAngle;\r\n    }\r\n}\r\n\r\nfunction sqdist(a,b){\r\n    var dx = b[0] - a[0];\r\n    var dy = b[1] - a[1];\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */\r\nfunction polygonAt(polygon, i){\r\n    var s = polygon.length;\r\n    return polygon[i < 0 ? i % s + s : i % s];\r\n}\r\n\r\n/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */\r\nfunction polygonClear(polygon){\r\n    polygon.length = 0;\r\n}\r\n\r\n/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */\r\nfunction polygonAppend(polygon, poly, from, to){\r\n    for(var i=from; i<to; i++){\r\n        polygon.push(poly[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */\r\nfunction polygonMakeCCW(polygon){\r\n    var br = 0,\r\n        v = polygon;\r\n\r\n    // find bottom right point\r\n    for (var i = 1; i < polygon.length; ++i) {\r\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\r\n            br = i;\r\n        }\r\n    }\r\n\r\n    // reverse poly if clockwise\r\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\r\n        polygonReverse(polygon);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */\r\nfunction polygonReverse(polygon){\r\n    var tmp = [];\r\n    var N = polygon.length;\r\n    for(var i=0; i!==N; i++){\r\n        tmp.push(polygon.pop());\r\n    }\r\n    for(var i=0; i!==N; i++){\r\n\t\tpolygon[i] = tmp[i];\r\n    }\r\n}\r\n\r\n/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {Boolean}\r\n */\r\nfunction polygonIsReflex(polygon, i){\r\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\r\n}\r\n\r\nvar tmpLine1=[],\r\n    tmpLine2=[];\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\r\nfunction polygonCanSee(polygon, a,b) {\r\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\r\n\r\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\r\n        return false;\r\n    }\r\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\r\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\r\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\r\n            continue;\r\n        }\r\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\r\n            l1[0] = polygonAt(polygon, a);\r\n            l1[1] = polygonAt(polygon, b);\r\n            l2[0] = polygonAt(polygon, i);\r\n            l2[1] = polygonAt(polygon, i + 1);\r\n            p = lineInt(l1,l2);\r\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee2\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\r\nfunction polygonCanSee2(polygon, a,b) {\r\n    // for each edge\r\n    for (var i = 0; i !== polygon.length; ++i) {\r\n        // ignore incident edges\r\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\r\n            continue;\r\n        }\r\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */\r\nfunction polygonCopy(polygon, i,j,targetPoly){\r\n    var p = targetPoly || [];\r\n    polygonClear(p);\r\n    if (i < j) {\r\n        // Insert all vertices from i to j\r\n        for(var k=i; k<=j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n    } else {\r\n\r\n        // Insert vertices 0 to j\r\n        for(var k=0; k<=j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n        // Insert vertices i to end\r\n        for(var k=i; k<polygon.length; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n    }\r\n\r\n    return p;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */\r\nfunction polygonGetCutEdges(polygon) {\r\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\r\n    var nDiags = Number.MAX_VALUE;\r\n\r\n    for (var i = 0; i < polygon.length; ++i) {\r\n        if (polygonIsReflex(polygon, i)) {\r\n            for (var j = 0; j < polygon.length; ++j) {\r\n                if (polygonCanSee(polygon, i, j)) {\r\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\r\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\r\n\r\n                    for(var k=0; k<tmp2.length; k++){\r\n                        tmp1.push(tmp2[k]);\r\n                    }\r\n\r\n                    if (tmp1.length < nDiags) {\r\n                        min = tmp1;\r\n                        nDiags = tmp1.length;\r\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */\r\nfunction polygonDecomp(polygon){\r\n    var edges = polygonGetCutEdges(polygon);\r\n    if(edges.length > 0){\r\n        return polygonSlice(polygon, edges);\r\n    } else {\r\n        return [polygon];\r\n    }\r\n}\r\n\r\n/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */\r\nfunction polygonSlice(polygon, cutEdges){\r\n    if(cutEdges.length === 0){\r\n\t\treturn [polygon];\r\n    }\r\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\r\n\r\n        var polys = [polygon];\r\n\r\n        for(var i=0; i<cutEdges.length; i++){\r\n            var cutEdge = cutEdges[i];\r\n            // Cut all polys\r\n            for(var j=0; j<polys.length; j++){\r\n                var poly = polys[j];\r\n                var result = polygonSlice(poly, cutEdge);\r\n                if(result){\r\n                    // Found poly! Cut and quit\r\n                    polys.splice(j,1);\r\n                    polys.push(result[0],result[1]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return polys;\r\n    } else {\r\n\r\n        // Was given one edge\r\n        var cutEdge = cutEdges;\r\n        var i = polygon.indexOf(cutEdge[0]);\r\n        var j = polygon.indexOf(cutEdge[1]);\r\n\r\n        if(i !== -1 && j !== -1){\r\n            return [polygonCopy(polygon, i,j),\r\n                    polygonCopy(polygon, j,i)];\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {Boolean}\r\n * @todo Should it check all segments with all others?\r\n */\r\nfunction polygonIsSimple(polygon){\r\n    var path = polygon, i;\r\n    // Check\r\n    for(i=0; i<path.length-1; i++){\r\n        for(var j=0; j<i-1; j++){\r\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check the segment between the last and the first point to all others\r\n    for(i=1; i<path.length-2; i++){\r\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\r\n\tdelta = delta || 0;\r\n\tvar a1 = p2[1] - p1[1];\r\n\tvar b1 = p1[0] - p2[0];\r\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\r\n\tvar a2 = q2[1] - q1[1];\r\n\tvar b2 = q1[0] - q2[0];\r\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\r\n\tvar det = (a1 * b2) - (a2 * b1);\r\n\r\n\tif(!scalar_eq(det,0,delta)){\r\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\r\n\t} else {\r\n\t\treturn [0,0];\r\n    }\r\n}\r\n\r\n/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */\r\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\r\n    maxlevel = maxlevel || 100;\r\n    level = level || 0;\r\n    delta = delta || 25;\r\n    result = typeof(result)!==\"undefined\" ? result : [];\r\n    reflexVertices = reflexVertices || [];\r\n    steinerPoints = steinerPoints || [];\r\n\r\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\r\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\r\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\r\n    var lowerPoly=[], upperPoly=[]; // polygons\r\n    var poly = polygon,\r\n        v = polygon;\r\n\r\n    if(v.length < 3){\r\n\t\treturn result;\r\n    }\r\n\r\n    level++;\r\n    if(level > maxlevel){\r\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\r\n        return result;\r\n    }\r\n\r\n    for (var i = 0; i < polygon.length; ++i) {\r\n        if (polygonIsReflex(poly, i)) {\r\n            reflexVertices.push(poly[i]);\r\n            upperDist = lowerDist = Number.MAX_VALUE;\r\n\r\n\r\n            for (var j = 0; j < polygon.length; ++j) {\r\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\r\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\r\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < lowerDist) { // keep only the closest intersection\r\n                            lowerDist = d;\r\n                            lowerInt = p;\r\n                            lowerIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\r\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\r\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < upperDist) {\r\n                            upperDist = d;\r\n                            upperInt = p;\r\n                            upperIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if there are no vertices to connect to, choose a point in the middle\r\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\r\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\r\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\r\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\r\n                steinerPoints.push(p);\r\n\r\n                if (i < upperIndex) {\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    if (lowerIndex !== 0){\r\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\r\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\r\n                    }\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\r\n                        polygonAppend(lowerPoly, poly,i,poly.length);\r\n                    }\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\r\n                }\r\n            } else {\r\n                // connect to the closest point within the triangle\r\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\r\n\r\n                if (lowerIndex > upperIndex) {\r\n                    upperIndex += polygon.length;\r\n                }\r\n                closestDist = Number.MAX_VALUE;\r\n\r\n                if(upperIndex < lowerIndex){\r\n                    return result;\r\n                }\r\n\r\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\r\n                    if (\r\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\r\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\r\n                    ) {\r\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\r\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\r\n                            closestDist = d;\r\n                            closestIndex = j % polygon.length;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (i < closestIndex) {\r\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\r\n                    if (closestIndex !== 0){\r\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\r\n                    }\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        polygonAppend(lowerPoly, poly,i,v.length);\r\n                    }\r\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\r\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\r\n                }\r\n            }\r\n\r\n            // solve smallest poly first\r\n            if (lowerPoly.length < upperPoly.length) {\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            } else {\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    result.push(polygon);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */\r\nfunction polygonRemoveCollinearPoints(polygon, precision){\r\n    var num = 0;\r\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\r\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\r\n            // Remove the middle point\r\n            polygon.splice(i%polygon.length,1);\r\n            num++;\r\n        }\r\n    }\r\n    return num;\r\n}\r\n\r\n/**\r\n * Remove duplicate points in the polygon.\r\n * @method removeDuplicatePoints\r\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\r\n */\r\nfunction polygonRemoveDuplicatePoints(polygon, precision){\r\n    for(var i=polygon.length-1; i>=1; --i){\r\n        var pi = polygon[i];\r\n        for(var j=i-1; j>=0; --j){\r\n            if(points_eq(pi, polygon[j], precision)){\r\n                polygon.splice(i,1);\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\r\nfunction scalar_eq(a,b,precision){\r\n    precision = precision || 0;\r\n    return Math.abs(a-b) <= precision;\r\n}\r\n\r\n/**\r\n * Check if two points are equal\r\n * @static\r\n * @method points_eq\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\r\nfunction points_eq(a,b,precision){\r\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\r\n}","import * as planck from 'planck-js';\r\nimport * as PIXI from 'pixi.js';\r\nimport Point from './Point';\r\nimport * as util from './util';\r\nimport Input from './Input';\r\nimport * as textures from './shaders/shaders';\r\nimport Triangulator from './math/triangulate'\r\nimport Convex from './math/convex'\r\nimport * as PIXIParticles from 'pixi-particles';\r\n\r\nconst definitions = {\r\n    ground: {\r\n        points: [[0, 200], [100, 190], [200, 170], [300, 120], [400, 40], [500, 20], [600, 30], [700, 60], [800, 40], [850, 10],\r\n        [5000, 10], [5000, 700], [200, 700], [100, 600], [60, 400]],\r\n        internal: 2,\r\n        colors: [{ color: 0xd3c7a2, position: 0 }, { color: 0xa69150, position: 150 }, { color: 0xdbd1b4, position: 300 }]\r\n    },\r\n    tree: {\r\n        points: [[250, 0], [300, 0], [300, 400], [250, 400], [250, 200], [110, 220], [50, 190], [35, 150], [50, 180], [100, 200], [250, 180]],\r\n        internal: 2,\r\n        colors: [{ color: 0x44340d, position: 0 }, { color: 0x4f3a07, position: 200 }]\r\n    }\r\n}\r\n\r\nconst darkenShaders = textures.darken();\r\n\r\nconst bakeScale = 2;\r\n\r\nclass World {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.app = this.game.app;\r\n        this.input = new Input(this);\r\n        this.objects = [];\r\n        this.physics = planck.World({\r\n            gravity: planck.Vec2(0, 0.01)\r\n        });\r\n        this.physicsStage = this.physics.createBody({\r\n            type: 'static',\r\n            position: planck.Vec2(0, 0),\r\n        });\r\n        this.game.resizeBus.push(() => {\r\n            this.background.clear();\r\n            this.background.beginFill(0x111111);\r\n            this.background.drawRect(0, 0, this.app.renderer.width + 20, this.app.renderer.height + 20);\r\n        });\r\n\r\n        // Generate stage textures\r\n        for (const key in definitions) {\r\n            const definition = definitions[key];\r\n            let max = 0;\r\n            //for (const point of definition.points) {\r\n            //    if (point[1] > max) {\r\n            //        max = point[1]\r\n            //    }\r\n            //}\r\n            definition.max = max;\r\n            //definition.points = definition.points.map(point => {\r\n            //    point[1] = max - point[1];\r\n            //    return point;\r\n            //});\r\n            Convex.makeCCW(definition.points);\r\n            //definition.points.reverse();\r\n            definition.shapes = [];\r\n            for (const polygon of Convex.decomp(definition.points)) {\r\n                definition.shapes.push({\r\n                    points: polygon.map(array => new Point(array[0], array[1]))\r\n                });\r\n            }\r\n            console.log(\"Definition '\" + key + \"' was split into \" + definition.shapes.length + \" convex polygons.\");\r\n            for (let index = 0; index < definition.shapes.length; index++) {\r\n                const shape = definition.shapes[index];\r\n                shape.texture = this.bakeStageTexture({\r\n                    name: key,\r\n                    index: index,\r\n                    internal: definition.internal,\r\n                    points: shape.points,\r\n                    colors: definition.colors\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    init() {\r\n        // Background\r\n        this.backgroundShader = textures.sky();\r\n        this.background = new PIXI.Graphics();\r\n        this.background.beginFill(0x111111);\r\n        this.background.drawRect(0, 0, this.app.renderer.width + 20, this.app.renderer.height + 20);\r\n        this.background.filters = [this.backgroundShader.shader]\r\n        this.app.stage.addChild(this.background);\r\n\r\n        this.addStageObject(850, -380, definitions.tree);\r\n        this.addStageObject(0, 0, definitions.ground);\r\n\r\n        this.createPlayer();\r\n        this.input.init();\r\n    }\r\n\r\n    tick(delta) {\r\n        const center = util.getScreenCenter();\r\n\r\n        this.physics.step(delta);\r\n        const playerPosition = this.player.body.getPosition();\r\n        this.player.sprite.x = util.scaleToWorld(playerPosition.x);\r\n        this.player.sprite.y = util.scaleToWorld(playerPosition.y);\r\n        this.player.sprite.rotation += this.player.body.getAngularVelocity() * delta;\r\n        this.app.stage.position.set(center.x - this.player.sprite.x, center.y - this.player.sprite.y);\r\n\r\n        this.background.x = this.player.sprite.x - center.x - 10;\r\n        this.background.y = this.player.sprite.y - center.y - 10;\r\n        this.tracer.updateOwnerPos(this.player.sprite.x, this.player.sprite.y);\r\n        this.tracer.update(delta * 0.01);\r\n\r\n        this.input.tick(delta);\r\n    }\r\n\r\n    createPlayer() {\r\n        const playerSize = 10;\r\n\r\n        // Graphics\r\n        const graphics = new PIXI.Graphics();\r\n        graphics.beginFill(0x0000ff);\r\n        graphics.drawCircle(0, 0, playerSize);\r\n        graphics.beginFill(0xff0000);\r\n        graphics.drawCircle(4, 0, playerSize / 3);\r\n        const sprite = new PIXI.Sprite(this.app.renderer.generateTexture(graphics));\r\n        sprite.anchor.x = 0.5;\r\n        sprite.anchor.y = 0.5;\r\n        sprite.x = 200;\r\n        sprite.y = 100;\r\n\r\n        // Physics\r\n        const body = this.physics.createBody({\r\n            type: 'dynamic',\r\n            position: planck.Vec2(40, -4),\r\n            bullet: true,\r\n            linearDamping: 0.005,\r\n            allowSleep: false\r\n        });\r\n        body.createFixture({\r\n            shape: planck.Circle(util.scaleToPhysics(playerSize)),\r\n            restitution: 0,\r\n            friction: 0.2,\r\n            density: 0.9\r\n        });\r\n\r\n        // Effects\r\n        const container = new PIXI.Container();\r\n        this.tracer = new PIXIParticles.Emitter(\r\n            container,\r\n            [PIXI.loader.resources[\"particle\"].texture],\r\n            {\r\n                \"alpha\": {\r\n                    \"start\": 1,\r\n                    \"end\": 0\r\n                },\r\n                \"scale\": {\r\n                    \"start\": 0.4,\r\n                    \"end\": 0.1,\r\n                    \"minimumScaleMultiplier\": 1\r\n                },\r\n                \"color\": {\r\n                    \"start\": \"#e4f9ff\",\r\n                    \"end\": \"#3fcbff\"\r\n                },\r\n                \"speed\": {\r\n                    \"start\": 0,\r\n                    \"end\": 0,\r\n                    \"minimumSpeedMultiplier\": 1\r\n                },\r\n                \"acceleration\": {\r\n                    \"x\": 0,\r\n                    \"y\": 0\r\n                },\r\n                \"maxSpeed\": 0,\r\n                \"startRotation\": {\r\n                    \"min\": 0,\r\n                    \"max\": 360\r\n                },\r\n                \"noRotation\": false,\r\n                \"rotationSpeed\": {\r\n                    \"min\": 0,\r\n                    \"max\": 0\r\n                },\r\n                \"lifetime\": {\r\n                    \"min\": 0.8,\r\n                    \"max\": 0.8\r\n                },\r\n                \"blendMode\": \"normal\",\r\n                \"frequency\": 0.001,\r\n                \"emitterLifetime\": -1,\r\n                \"maxParticles\": 1000,\r\n                \"pos\": {\r\n                    \"x\": 0,\r\n                    \"y\": 0\r\n                },\r\n                \"addAtBack\": true,\r\n                \"spawnType\": \"point\"\r\n            }\r\n        );\r\n        this.tracer.emit = true;\r\n        this.app.stage.addChild(container);\r\n        this.app.stage.addChild(sprite);\r\n\r\n        this.player = {\r\n            sprite: sprite,\r\n            body: body\r\n        }\r\n    }\r\n\r\n    bakeStageTexture(def) {\r\n        def = {\r\n            ...def,\r\n            points: def.points.map(point => point.multiply(bakeScale, bakeScale)),\r\n            colors: def.colors.map(color => { return { color: color.color, position: color.position * bakeScale } })\r\n        }\r\n        const start = new Date();\r\n        const graphics = new PIXI.Graphics();\r\n        graphics.beginFill(0x000000);\r\n        graphics.drawPolygon(def.points.map(point => point.multiply(1, 1).toPixiPoint()));\r\n        graphics.endFill();\r\n        const bounds = graphics.getBounds();\r\n        const container = new PIXI.Container();\r\n        const textures = [];\r\n        const pointsets = [];\r\n        const internal = [];\r\n\r\n        for (let i = 0; i < def.internal; i++) {\r\n            let point = null;\r\n            do {\r\n                point = new Point(bounds.x + Math.floor(Math.random() * bounds.width), bounds.y + Math.floor(Math.random() * bounds.height));\r\n            } while (!util.inside(point.toArray(), def.points.map(point => point.toArray())));\r\n            internal.push(point);\r\n        }\r\n\r\n        const points = [...def.points, ...internal];\r\n        const triangles = Triangulator.from(points.map(point => point.toArray())).triangles;\r\n        for (let i = 0; i < triangles.length; i += 3) {\r\n            pointsets.push([\r\n                points[triangles[i]],\r\n                points[triangles[i + 1]],\r\n                points[triangles[i + 2]]\r\n            ]);\r\n        }\r\n\r\n        for (let index = 0; index < pointsets.length; index++) {\r\n            const points = pointsets[index];\r\n            const texture = new PIXI.Graphics();\r\n            texture.beginFill(0xffffff);\r\n            texture.drawPolygon(points.map(point => point.toPixiPoint()));\r\n            texture.endFill();\r\n            const shape = texture.getBounds();\r\n            texture.clear();\r\n\r\n            // Interpolate colors\r\n            const x = shape.x;\r\n            let primary = 0x000000;\r\n            let primaryDistance = -1;\r\n            let accent = 0xffffff;\r\n            let accentDistance = -1;\r\n            for (const color of def.colors) {\r\n                const disance = Math.abs(x - color.position);\r\n                if (primaryDistance === -1) {\r\n                    primaryDistance = disance;\r\n                    primary = color.color;\r\n                    accent = primary;\r\n                    accentDistance = primaryDistance;\r\n                    continue;\r\n                }\r\n                if (disance < primaryDistance) {\r\n                    accent = primary;\r\n                    accentDistance = primaryDistance;\r\n                    primaryDistance = disance;\r\n                    primary = color.color;\r\n                }\r\n            }\r\n            const ratio = accentDistance === 0 ? 1 : primaryDistance / accentDistance;\r\n            const r = (((primary >> 16) & 255) * (1 - ratio)) + (((accent >> 16) & 255) * (ratio));\r\n            const g = (((primary >> 8) & 255) * (1 - ratio)) + (((accent >> 8) & 255) * (ratio));\r\n            const b = ((primary & 255) * (1 - ratio)) + ((accent & 255) * (ratio));\r\n            const color = 0x1000000 + (r << 16) + (g << 8) + b;\r\n\r\n            texture.beginFill(color);\r\n            texture.drawPolygon(points.map(point => point.toPixiPoint()));\r\n            texture.endFill();\r\n            const tex = this.app.renderer.generateTexture(texture);\r\n            textures.push(tex);\r\n            const sprite = new PIXI.Sprite(tex);\r\n            sprite.filters = [darkenShaders[index % darkenShaders.length]];\r\n            sprite.blendMode = PIXI.BLEND_MODES.ADD;\r\n            sprite.x = shape.x;\r\n            sprite.y = shape.y;\r\n            container.addChild(sprite);\r\n        }\r\n        //container.filters = [darkenShaders[1], darkenShaders[1]];\r\n        const render = new PIXI.RenderTexture(new PIXI.BaseRenderTexture(bounds.width + bounds.x, bounds.height + bounds.y, PIXI.SCALE_MODES.LINEAR, 1));\r\n        this.app.renderer.render(container, render);\r\n        for (const texture of textures) {\r\n            texture.destroy();\r\n        }\r\n\r\n        const end = new Date();\r\n        console.log(\"Texture '\" + def.name + \"' polygon \" + def.index + \" bake took \" + (end - start) + \"ms\");\r\n\r\n        return render;\r\n    }\r\n\r\n    addStageObject(x, y, def) {\r\n        let index = 0;\r\n        for (const shape of def.shapes) {\r\n            index++;\r\n            // Graphics\r\n            const sprite = new PIXI.Sprite(shape.texture);\r\n            sprite.x = x;\r\n            sprite.y = y - def.max;\r\n            sprite.scale.x = 1 / bakeScale;\r\n            sprite.scale.y = 1 / bakeScale;\r\n            this.app.stage.addChild(sprite);\r\n\r\n            // Physics\r\n            const fixture = this.physicsStage.createFixture({\r\n                shape: planck.Polygon(shape.points.map(point => point.add(x, y - def.max).scaleToPhysics().toVec2())),\r\n                friction: 0.9,\r\n                restitution: 0.8\r\n            });\r\n\r\n            // Add\r\n            const object = {\r\n                fixture: fixture,\r\n                sprite: sprite\r\n            };\r\n            this.objects.push(object);\r\n        }\r\n    }\r\n}\r\n\r\nexport default World;\r\n","import * as PIXI from 'pixi.js';\r\nimport World from './World';\r\nimport * as planck from 'planck-js';\r\n\r\nclass Game {\r\n    constructor() {\r\n        PIXI.settings.PRECISION_FRAGMENT = PIXI.PRECISION.HIGH; // Big hack for fxaa\r\n        planck.internal.Settings.velocityThreshold = 0.1; // Bounce\r\n        this.app = new PIXI.Application({ width: window.innerWidth, height: window.innerHeight, transparent: false });\r\n        this.app.renderer.autoResize = true;\r\n        this.resizeBus = [\r\n            () => this.app.renderer.resize(window.innerWidth, window.innerHeight)\r\n        ]\r\n        window.onresize = () => this.resize();\r\n        this.world = new World(this);\r\n    }\r\n\r\n    injectPixiContext(element) {\r\n        if (element && element.children.length <= 0) {\r\n            element.appendChild(this.app.view);\r\n            PIXI.loader.add(\"particle\", \"assets/sprites/particle.png\").load(() => this.initializeRender());\r\n        }\r\n    }\r\n\r\n    initializeRender() {\r\n        this.world.init();\r\n        this.app.ticker.add(delta => this.tick(delta));\r\n        this.app.stage.filters = [new PIXI.filters.FXAAFilter()];\r\n    }\r\n\r\n    tick(delta) {\r\n        this.world.tick(delta);\r\n    }\r\n\r\n    resize() {\r\n        for (let handler of this.resizeBus) {\r\n            handler();\r\n        }\r\n    }\r\n}\r\n\r\nexport default Game;","import React, { Component } from 'react';\nimport './App.css';\nimport Game from './game/Game';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.game = new Game();\n  }\n\n  render() {\n    return (\n      <div ref={element => this.game.injectPixiContext(element)} />\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}